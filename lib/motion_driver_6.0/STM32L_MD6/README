*******************************************************************************
TODO:
- re-tab all files
- remove non MPU9150 specific code (ifdef...)
- compiled with GNU non-eabi-arm 4.7 => check diff with 4.8 !!
- compare arm and msp430
- flash write for calibration:
github.com/finnurtorfa/nrf51/tree/master/lib/nrf51sdk/Nordic/nrf51822/Board/nrf6310/flashwrite_example

*******************************************************************************

Content of this directory:

- src/main.c :     the main function and main loop for the project application.
- core/eMPL-hal :  the files that provide same the sensor data conversion such as linear acceleration.
- core/driver :    the InvenSense drivers layer for the MPU devices as well as the MCU specific drivers
- core/mllite :    the MPL data processing functions that store the received sensor data and processes the data.
- core/mpl :       the InvenSense Proprietary MPL library – a library containing advanced algorithms for sensor fusion and run-time calibrations.


A) Required for integration
===========================

1) Driver / Platform-specific:
   - OK: I2C read/write.
   - OK? System clock (ms).
   - OK? Hardware interrupts.
   - OK? Log outputs.
2) Motion Processing Libraries
3) Sample HAL
4) main


1) Driver Layer
---------------

core/driver/eMPL consists of these files:

- inv_mpu.c: the driver which can be easily ported to different embedded platforms.
- inv_mpu.h: the structures and prototypes for the InvenSense driver.

- inv_mpu_dmp_motion_driver.c: the driver for containing the DMP image and the APIs to load and configure the DMP.
- inv_mpu_dmp_motion_driver.h: contains the prototypes and defines for the DMP features

- dmpKey.h: Contains the defines for DMP memory locations for DMP features
- dmpmap.h: Contains the defines for DMP memory locations


The following functions need to be defined in inv_mpu.c and inv_mpu_dmp_motion_driver.c.
Below is an example as shown for the MSP430 platform.

    #define i2c_write  msp430_i2c_write
    #define i2c_read   msp430_i2c_read
    #define delay_ms   msp430_delay_ms
    #define get_ms     msp430_get_clock_ms  /* TODO: check app_timer + battery measurements */
    #define log_i      MPL_LOGI
    #define log_e      MPL_LOGE

- i2c_write and i2c_read: these will need to be linked to the i2c drivers.
This functions will take in 4 parameters then perform the i2c transaction:
    unsigned char slave_addr
    unsigned char reg_addr
    unsigned char length
    unsigned char *data

- delay_ms: takes in one unsigned long parameter

- get_ms: Timestamp are usually an unsigned long and in milliseconds.

- log_i and log_e: log informational or error messages.
The logging code is located in the file log_msp430.c or log_stm32l.c.


2) MPL Library
--------------
This Motion Apps algorithms consists of 2 directories:
- core/mllite
- core/mpl

No porting required !
May need to include system specific header files to support function calls in mllite:
- memcpy
- memset
- ...
- TODO: DIG !!!


3) eMPL-HAL
-----------

Contains the APIs to get various data from the MPL library.
The data you can obtain are from the following APIs functions:

    int  inv_get_sensor_type_accel    (long *data, int8_t *accuracy, inv_time_t *timestamp); // TODO: DIG !!!
    int  inv_get_sensor_type_gyro     (long *data, int8_t *accuracy, inv_time_t *timestamp);
    int  inv_get_sensor_type_compass  (long *data, int8_t *accuracy, inv_time_t *timestamp);
    int  inv_get_sensor_type_quat     (long *data, int8_t *accuracy, inv_time_t *timestamp);
    int  inv_get_sensor_type_euler    (long *data, int8_t *accuracy, inv_time_t *timestamp); // TODO: DIG !!!
    int  inv_get_sensor_type_rot_mat  (long *data, int8_t *accuracy, inv_time_t *timestamp);
    int  inv_get_sensor_type_heading  (long *data, int8_t *accuracy, inv_time_t *timestamp); // TODO: DIG !!!
    int  inv_get_sensor_type_linear_acceleration(float *values, int8_t *accuracy, inv_time_t * timestamp)


4) main
-------

Contains a specific application that:

- Handles of sensor data processing from the MPU device
- Handles input requests from the client
- Does Power management
- Initializes the MPL library, DMP, and the hardware
- Handles the interrupts


B) Initialization APIs =>  TODO: DIG !!!
======================

At power on, the MPU device will provide sensor data in it default state.
The inv_mpu.c provides a reference API on how to initialize the MPU device with some basic configurations such as powering on the sensors and setting the scale range and sampling rate:

    int  mpu_init                     (struct int_param_s *int_param)
    int  mpu_set_gyro_fsr             (unsigned short fsr)            // full scale range...
    int  mpu_set_accel_fsr            (unsigned char  fsr)
    int  mpu_set_lpf                  (unsigned short lpf)
    int  mpu_set_sample_rate          (unsigned short rate)
    int  mpu_set_compass_sample_rate  (unsigned short rate)
    int  mpu_configure_fifo           (unsigned char  sensors)
    int  mpu_set_sensors              (unsigned char  sensors)


C) Orientation Matrix
=====================

See Transformation chart.pdf, and:
    struct  platform_data_s  gyro_pdata
    struct  platform_data_s  compass_pdata


D) Interrupts Handling
======================

Can be programmed to be generated either at
- FIFO output rate
- DMP generated
- gesture detected

In main.c, when sensor data is ready, interrupt is generated, the routine sets a global flag new_gyro to 1.

Functions related to interrupts:
    int  dmp_set_interrupt_mode (unsigned char mode)
    static int  set_int_enable  (unsigned char enable)


E) DMP - Digital Motion Processor
=================================

Performs hardware high-frequency motion algorithm computation.
See Projects/eMD6/core/driver/eMPL:
- inv_mpu_dmp_motion_driver.*
- dmpKey.h
- dmpMap.h.


F) DMP Intialization
====================

The DMP firmware code is 3kB image found in the structure:
static const unsigned char dmp_memory[DMP_CODE_SIZE]

This image needs to be downloaded into the DMP memory banks.
After downloading, a starting address needs to be provided, then the DMP state needs to be turned on.

=> TODO find how starting address can be provided !!

APIs related to DMP initialization are the following:
    int dmp_load_motion_driver_firmware(void)
    int dmp_set_fifo_rate(unsigned short rate)
    int mpu_set_dmp_state(unsigned char enable)

The initialization can be found in the main function right before the while(1) loop.
TODO: see line 849, "To initialize the DMP"


G) DMP Features
===============

The DMP features many functions as detailed in the Features Guide. These functions can be dynamically
enabled and disabled using:

int dmp_enable_feature(unsigned char mask);


The mask can be made with:

    #define  DMP_FEATURE_TAP             (0x001)
    #define  DMP_FEATURE_ANDROID_ORIENT  (0x002) // TODO find why android
    #define  DMP_FEATURE_LP_QUAT         (0x004) // Low power ?
    #define  DMP_FEATURE_PEDOMETER       (0x008)
    #define  DMP_FEATURE_6X_LP_QUAT      (0x010)
    #define  DMP_FEATURE_GYRO_CAL        (0x020)
    #define  DMP_FEATURE_SEND_RAW_ACCEL  (0x040)
    #define  DMP_FEATURE_SEND_RAW_GYRO   (0x080)
    #define  DMP_FEATURE_SEND_CAL_GYRO   (0x100)

For Tap and Orientation data parsing, the MD6 drivers define 2 call back functions which will handle the parsing and log it to the python client:

    int dmp_register_tap_cb(void (*func)(unsigned char, unsigned char))
    int dmp_register_android_orient_cb(void (*func)(unsigned char))

The callbacks will need to be defined MD6 driver. The related APIs are:

    static int decode_gesture(unsigned char *gesture)
    static void tap_cb(unsigned char direction, unsigned char count)
    static void android_orient_cb(unsigned char orientation)

There are also some configurable settings for Tap such as threshold. The APIs are available in:
    core/driver/eMPL/inv_mpu_dmp_motion_driver.*


H) [DMP FIFO Output]
====================

DMP only writes to the FIFO when specific features are enabled such as tap or sensor data. The MD6 driver will wait for the DMP to generate an interrupt, and then read the contents of the FIFO.
FIFO format is dependent on which DMP features are enabled.The DMP FIFO output format can be seen in the API function.

    int dmp_read_fifo(short *gyro, short *accel, long *quat,
    unsigned long *timestamp, short *sensors, unsigned char *more);


I) [InvenSense Hardware Self-test]
==================================

Optional factory line test:
    static inline void run_self_test(void)

The followomg returns the status of the each axis of the sensor and the accel and gyro bias for calibration:
    int mpu_run_self_test(long *gyro, long *accel)

Parameters for the self-test function are shown below:

    I/O     accel   Returns the accel bias.
    I/O     gyro    Returns the gyro bias.
    output  result  The function returns the result of the self-test as shown in the table below.

Return value of ‘results’ is defined as the following with a ‘1’:

    0x01    Gyro Sensor Status
    0x02    Accel Sensor Status
    0x04    Compass Sensor status

If the value returned is not a 0x07 this signifies that the particular sensor failed.
TODO: run eMPL-client.py to get the calibration values.


J) Calibration Data and Storage !
=================================

Calibration data may change slowly over time, temperature, and environment, so Invensense provides several in-use sensor calibration algorithms, which will constantly calibrate the sensors throughout its lifetime.


1) Factory Line calibration
---------------------------

The MD6.0 by default pushed the biases into the MPL library and lets the fusion engine apply the bias data.
However customers can use the Hardware Offset Register by defining the following in main.c:
    USE_CAL_HW_REGISTERS

The difference is that, if using the HW offset registers, the MEMS data will automatically be adjusted before it is pushed into the sensor data registers.

See the app note ‘MPU HW Offset Registers’.


2 Saving and Loading Calibration Data
-------------------------------------

Examples on how to save and load the calibration data from a memory location:
    inv_error_t inv_save_mpl_states(unsigned char *data, size_t sz)             // save
    inv_error_t inv_load_mpl_states(const unsigned char *data, size_t length)   // load


K) Integrating the MPL Library
==============================

After the library is linked the code will need to enabled the library and it’s features.
The library initialization can be found in the main function before the main loop.
The features are described in the Feature Guide.
Here are the associated APIs:
    inv_error_t inv_init_mpl(void)
    inv_error_t inv_enable_quaternion(void)             // enable 6-axis
    inv_error_t inv_enable_9x_sensor_fusion(void)       // enable 9-axis fusion
    inv_error_t inv_enable_fast_nomot(void)             // gyro in-use calibration
    inv_error_t inv_enable_gyro_tc(void)                // gyro temperature compensation
    inv_error_t inv_enable_vector_compass_cal(void)     // compass calibration
    inv_error_t inv_enable_magnetic_disturbance(void)   // magnetic disturbance
    inv_error_t inv_enable_eMPL_outputs(void)
    inv_error_t inv_start_mpl(void)


L) Compiler Specific Setting
============================

To compile for the different parts (MPU6050, MPU9150, MPU6500, and MPU9250), you will need to set the compiler flag. The default symbols needed are:
- MPL_LOG_NDEBUG=1
- MPU9150 or MPU6050 or MPU6500 or MPU9250
- EMPL
- USE_DMP
- EMPL_TARGET_MSP430 or its equivalent

